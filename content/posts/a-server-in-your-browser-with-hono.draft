+++
date = '2026-02-05T11:18:01+07:00'
draft = true
title = 'A Server in Your Browser With Hono'
description = ''
tags = []
+++

Javascript executes in an event loop, for all intents and purposes it is 'single-threaded' though the actual implementation may contain multiple threads - this is transparent and inaccessible to the developer. Multi-tasking is virtualized. Long running processing can jank the ui or the lock-up the main thread, dropping frames etc. In advanced use cases, intense processing is delegated to web-workers. Post message; essentially an event emitter, is used as the interface boundary for what is essentially a RPC 

A popular library to 'remove the mental barrier of thinking about postMessage' is [Comlink](https://github.com/GoogleChromeLabs/comlink) After some careful setup, Comlink can make the call signatures of class instances and functions the same as if they were in the main thread. The only caveat is they must be called asynchronously. We can consider Comlink, as a sort of convenient async-RPC.

Comlink (when done right) is a very elegant solution in that hides away the postMessage boundary, transforming these call signatures into what you would expect of the same calling a function in the main thread - No callbacks or post messages, you just call the RPC empowered function plainly. _Its magic_ BUT anecdotally I found this 'magic' often times working against me, making debugging difficult, serialization of special objects can be opaque. Calling is also done through es6 proxying, errors stacks can be confusing, as well as the mental model of how things 'work' when accessing properties. 

As a web developers the type of async RPC we are most familiar with is a 'fetch' This is an over-simplification, but for sake of argument I think this generalization stands pretty well. Not only is this mental model very familiar to us, there is also a plethora of tools to work with this async RPC. The shared pain of remote async calls otherwise gets remediated with tools like Tanstack Query. 

Enter service-workers! A service worker, is essentially a single web worker, operating on a given root path, shared amongst tabs and windows. Service workers generally serve as a way to do advanced caching logic. But I am proposing they can do more. They can access many of the same methods and apis available to web workers. 

Service workers use event emitters for input/output, similar to web workers,  `addEventListener("fetch", (event) => { })`, but the inner workings inline to the domain of responding to a web request. In fact cloudflare [hono](https://hono.dev/docs/getting-started/service-worker) can easily hook up to this. 

They also give us a couple of nice features not easily available to use in web-workers, the Cache API and Abort Controllers. A large chunk of data, stored locally in local storage like IndexedDb or OPFS, could easily be served, responding with ` if (cache.match(request)) return cache.get(request)` This not only could turn an otherwise 250ms round-trip into a 20ms one. Leaving the browser to manage the Cache resources, so you don't have to implement something which resembles an LRU yourself.

The Abort Controller, works natively with `fetch` api, `fetch("/service-worker/foobar", { abort })` Making for an easy setup for auto-completion enabled search inputs. The service-worker service side, also has access to cancelling as `request.signal` Setting up and terminating web-workers is expensive and I do not recommend it `worker.terminate()` Optionally, the abort signals *can* be hooked up in a way to be communicated across the boundary in Comlink to the web-worker. You'll have to dig through documentation to find out how. This is a good example of why I am vouching for service workers. The apis are all familiar too us! In service-workers, Abort Signals are native, and the operation is transparent. A great use case for abortable auto completion search for service workers, is searching documents stored in local storage or OPFS.

Web-workers make it possible to Share a large chunk of data, without copying, via the `SharedArrayBuffer` and Comlink handles this use case well. Service workers are similarly capable in the sharing is done when uploading via fetch as a File type - _so the process is the same or nearly as fast!_

Service workers work within this async fetch client-server boundary. It's familiar to us, and it works well with existing tools; Tanstack Query and Hono Server.

from the docs, this is all it takes to get hono up and running in your service worker.

```javascript

import { Hono } from 'hono'
import { fire } from 'hono/service-worker'

const app = new Hono().basePath('/sw')
app.get('/', (c) => c.text('Hello World'))

fire(app)

```

Hono is also an excellent choice for a few reasons. 
- Hono is lightweight *~18KB.* 
- Error handling for different routes can easily be accomplished with:

  ```javascript
  app.onError((err, c) => {
    console.error(`An error occurred: ${err.message}`);
    // Return a custom response
    return c.text('Custom Internal Server Error', 500);
  });
  ```

- It can export an [RPC client](https://hono.dev/docs/guides/rpc), making for easy to use typescript auto-completing in your IDE
- It works very well with ZOD validations, so you are given runtime input type validation


One use case of service-workers, where they really shine for background processing and local storage retrieval would be using service workers to convert png and jpgs to webp - and any similar image processing with [Offscreen canvas](https://web.dev/articles/offscreen-canvas). Not only is this done quickly, thanks to Files being shared not copied on upload, conversion to webp being not only possible but easy! You can store this image in your local data storage, opfs/indexedb, in your front-end `<img src="/sw/image.webp" />` and then use Cache api to quickly serve subsequent requests to `/sw/image.webp` for your image tags. This is all-in-all a great alternative to conjuring and managing lifetimes of blobs; `URL.createObjectURL(blob)` Natively using img tags and the Cache api, these abstractions are all handled for you. All while happening on another thread in the background, leaving your main thread buzzing away. 

Image conversion looks something like this:

```javascript
const canvas = new OffscreenCanvas(w,h);
  const ctx = canvas.getContext("2d");
  ctx.drawImage(imageBitmap, 0, 0);
  const webpBlob = await canvas.convertToBlob({
    type: "image/webp",
    quality: 0.8,
  });

```




